/* automatically generated by rust-bindgen 0.68.1 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const FFX_MAX_NUM_SRVS: u32 = 16;
pub const FFX_MAX_NUM_UAVS: u32 = 8;
pub const FFX_MAX_NUM_CONST_BUFFERS: u32 = 2;
pub const FFX_MAX_CONST_SIZE: u32 = 64;
pub const FFX_UNSPECIFIED_VERSION: u32 = 4294946048;
pub const FFX_MAXIMUM_PATH: u32 = 260;
pub const FFX_FSR2_VERSION_MAJOR: u32 = 2;
pub const FFX_FSR2_VERSION_MINOR: u32 = 2;
pub const FFX_FSR2_VERSION_PATCH: u32 = 0;
pub const FFX_FSR2_CONTEXT_SIZE: u32 = 16536;
#[doc = "< Unknown format"]
pub const FFX_SURFACE_FORMAT_UNKNOWN: SurfaceFormat = 0;
#[doc = "< 32 bit per channel, 4 channel typeless format"]
pub const FFX_SURFACE_FORMAT_R32G32B32A32_TYPELESS: SurfaceFormat = 1;
#[doc = "< 32 bit per channel, 4 channel float format"]
pub const FFX_SURFACE_FORMAT_R32G32B32A32_FLOAT: SurfaceFormat = 2;
#[doc = "< 16 bit per channel, 4 channel float format"]
pub const FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT: SurfaceFormat = 3;
#[doc = "< 16 bit per channel, 4 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R16G16B16A16_UNORM: SurfaceFormat = 4;
#[doc = "< 32 bit per channel, 2 channel float format"]
pub const FFX_SURFACE_FORMAT_R32G32_FLOAT: SurfaceFormat = 5;
#[doc = "< 32 bit per channel, 1 channel float format"]
pub const FFX_SURFACE_FORMAT_R32_UINT: SurfaceFormat = 6;
#[doc = "<  8 bit per channel, 4 channel float format"]
pub const FFX_SURFACE_FORMAT_R8G8B8A8_TYPELESS: SurfaceFormat = 7;
#[doc = "<  8 bit per channel, 4 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R8G8B8A8_UNORM: SurfaceFormat = 8;
#[doc = "< 32 bit 3 channel float format"]
pub const FFX_SURFACE_FORMAT_R11G11B10_FLOAT: SurfaceFormat = 9;
#[doc = "< 16 bit per channel, 2 channel float format"]
pub const FFX_SURFACE_FORMAT_R16G16_FLOAT: SurfaceFormat = 10;
#[doc = "< 16 bit per channel, 2 channel unsigned int format"]
pub const FFX_SURFACE_FORMAT_R16G16_UINT: SurfaceFormat = 11;
#[doc = "< 16 bit per channel, 1 channel float format"]
pub const FFX_SURFACE_FORMAT_R16_FLOAT: SurfaceFormat = 12;
#[doc = "< 16 bit per channel, 1 channel unsigned int format"]
pub const FFX_SURFACE_FORMAT_R16_UINT: SurfaceFormat = 13;
#[doc = "< 16 bit per channel, 1 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R16_UNORM: SurfaceFormat = 14;
#[doc = "< 16 bit per channel, 1 channel signed normalized format"]
pub const FFX_SURFACE_FORMAT_R16_SNORM: SurfaceFormat = 15;
#[doc = "<  8 bit per channel, 1 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R8_UNORM: SurfaceFormat = 16;
#[doc = "<  8 bit per channel, 1 channel unsigned int format"]
pub const FFX_SURFACE_FORMAT_R8_UINT: SurfaceFormat = 17;
#[doc = "<  8 bit per channel, 2 channel unsigned normalized format"]
pub const FFX_SURFACE_FORMAT_R8G8_UNORM: SurfaceFormat = 18;
#[doc = "< 32 bit per channel, 1 channel float format"]
pub const FFX_SURFACE_FORMAT_R32_FLOAT: SurfaceFormat = 19;
#[doc = " An enumeration of surface formats."]
pub type SurfaceFormat = ::std::os::raw::c_int;
#[doc = "< No usage flags indicate a resource is read only."]
pub const FFX_RESOURCE_USAGE_READ_ONLY: ResourceUsage = 0;
#[doc = "< Indicates a resource will be used as render target."]
pub const FFX_RESOURCE_USAGE_RENDERTARGET: ResourceUsage = 1;
#[doc = "< Indicates a resource will be used as UAV."]
pub const FFX_RESOURCE_USAGE_UAV: ResourceUsage = 2;
#[doc = " An enumeration of resource usage."]
pub type ResourceUsage = ::std::os::raw::c_int;
#[repr(i32)]
#[doc = " An enumeration of resource states."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ResourceStates {
    #[doc = "< Indicates a resource is in the state to be used as UAV."]
    UNORDERED_ACCESS = 1,
    #[doc = "< Indicates a resource is in the state to be read by compute shaders."]
    COMPUTE_READ = 2,
    #[doc = "< Indicates a resource is in the state to be used as source in a copy command."]
    COPY_SRC = 4,
    #[doc = "< Indicates a resource is in the state to be used as destination in a copy command."]
    COPY_DEST = 8,
    #[doc = "< Indicates a resource is in generic (slow) read state."]
    GENERIC_READ = 6,
}
#[doc = "< A resource with a single dimension."]
pub const FFX_RESOURCE_DIMENSION_TEXTURE_1D: ResourceDimension = 0;
#[doc = "< A resource with two dimensions."]
pub const FFX_RESOURCE_DIMENSION_TEXTURE_2D: ResourceDimension = 1;
#[doc = " An enumeration of surface dimensions."]
pub type ResourceDimension = ::std::os::raw::c_int;
#[doc = "< No flags."]
pub const FFX_RESOURCE_FLAGS_NONE: ResourceFlags = 0;
#[doc = "< A bit indicating a resource does not need to persist across frames."]
pub const FFX_RESOURCE_FLAGS_ALIASABLE: ResourceFlags = 1;
#[doc = " An enumeration of surface dimensions."]
pub type ResourceFlags = ::std::os::raw::c_int;
#[doc = "< The resource view is an unordered access view (UAV)."]
pub const FFX_RESOURCE_VIEW_UNORDERED_ACCESS: ResourceViewType = 0;
#[doc = "< The resource view is a shader resource view (SRV)."]
pub const FFX_RESOURCE_VIEW_SHADER_READ: ResourceViewType = 1;
#[doc = " An enumeration of all resource view types."]
pub type ResourceViewType = ::std::os::raw::c_int;
#[doc = "< Point sampling."]
pub const FFX_FILTER_TYPE_POINT: FilterType = 0;
#[doc = "< Sampling with interpolation."]
pub const FFX_FILTER_TYPE_LINEAR: FilterType = 1;
#[doc = " The type of filtering to perform when reading a texture."]
pub type FilterType = ::std::os::raw::c_int;
#[doc = "< Shader model 5.1."]
pub const FFX_SHADER_MODEL_5_1: ShaderModel = 0;
#[doc = "< Shader model 6.0."]
pub const FFX_SHADER_MODEL_6_0: ShaderModel = 1;
#[doc = "< Shader model 6.1."]
pub const FFX_SHADER_MODEL_6_1: ShaderModel = 2;
#[doc = "< Shader model 6.2."]
pub const FFX_SHADER_MODEL_6_2: ShaderModel = 3;
#[doc = "< Shader model 6.3."]
pub const FFX_SHADER_MODEL_6_3: ShaderModel = 4;
#[doc = "< Shader model 6.4."]
pub const FFX_SHADER_MODEL_6_4: ShaderModel = 5;
#[doc = "< Shader model 6.5."]
pub const FFX_SHADER_MODEL_6_5: ShaderModel = 6;
#[doc = "< Shader model 6.6."]
pub const FFX_SHADER_MODEL_6_6: ShaderModel = 7;
#[doc = "< Shader model 6.7."]
pub const FFX_SHADER_MODEL_6_7: ShaderModel = 8;
#[doc = " An enumeration of all supported shader models."]
pub type ShaderModel = ::std::os::raw::c_int;
#[doc = "< The resource is a buffer."]
pub const FFX_RESOURCE_TYPE_BUFFER: ResourceType = 0;
#[doc = "< The resource is a 1-dimensional texture."]
pub const FFX_RESOURCE_TYPE_TEXTURE1D: ResourceType = 1;
#[doc = "< The resource is a 2-dimensional texture."]
pub const FFX_RESOURCE_TYPE_TEXTURE2D: ResourceType = 2;
#[doc = "< The resource is a 3-dimensional texture."]
pub const FFX_RESOURCE_TYPE_TEXTURE3D: ResourceType = 3;
pub type ResourceType = ::std::os::raw::c_int;
#[doc = "< Local memory."]
pub const FFX_HEAP_TYPE_DEFAULT: HeapType = 0;
#[doc = "< Heap used for uploading resources."]
pub const FFX_HEAP_TYPE_UPLOAD: HeapType = 1;
#[doc = " An enumeration for different heap types"]
pub type HeapType = ::std::os::raw::c_int;
#[doc = "< The GPU job is performing a floating-point clear."]
pub const FFX_GPU_JOB_CLEAR_FLOAT: GpuJobType = 0;
#[doc = "< The GPU job is performing a copy."]
pub const FFX_GPU_JOB_COPY: GpuJobType = 1;
#[doc = "< The GPU job is performing a compute dispatch."]
pub const FFX_GPU_JOB_COMPUTE: GpuJobType = 2;
#[doc = " An enumberation for different render job types"]
pub type GpuJobType = ::std::os::raw::c_int;
#[doc = " A typedef representing the graphics device."]
pub type Device = *mut ::std::os::raw::c_void;
#[doc = " A typedef representing a command list or command buffer."]
#[repr(transparent)]
#[derive(Debug, Copy, Clone)]
pub struct CommandList(pub *mut ::std::os::raw::c_void);
#[doc = " A typedef for a root signature."]
pub type RootSignature = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a pipeline state object."]
pub type Pipeline = *mut ::std::os::raw::c_void;
#[doc = " A structure encapasulating a collection of device capabilities."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceCapabilities {
    #[doc = "< The minimum shader model supported by the device."]
    pub minimumSupportedShaderModel: ShaderModel,
    #[doc = "< The minimum supported wavefront width."]
    pub waveLaneCountMin: u32,
    #[doc = "< The maximum supported wavefront width."]
    pub waveLaneCountMax: u32,
    #[doc = "< The device supports FP16 in hardware."]
    pub fp16Supported: bool,
    #[doc = "< The device supports raytracing."]
    pub raytracingSupported: bool,
}
impl Default for DeviceCapabilities {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating a 2-dimensional point, using 32bit unsigned integers."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Dimensions2D {
    #[doc = "< The width of a 2-dimensional range."]
    pub width: u32,
    #[doc = "< The height of a 2-dimensional range."]
    pub height: u32,
}
#[doc = " A structure encapsulating a 2-dimensional point,"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IntCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: i32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: i32,
}
#[doc = " A structure encapsulating a 2-dimensional set of floating point coordinates."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FloatCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: f32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: f32,
}
#[doc = " A structure describing a resource."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResourceDescription {
    #[doc = "< The type of the resource."]
    pub type_: ResourceType,
    #[doc = "< The surface format."]
    pub format: SurfaceFormat,
    #[doc = "< The width of the resource."]
    pub width: u32,
    #[doc = "< The height of the resource."]
    pub height: u32,
    #[doc = "< The depth of the resource."]
    pub depth: u32,
    #[doc = "< Number of mips (or 0 for full mipchain)."]
    pub mipCount: u32,
    #[doc = "< A set of <c><i>FfxResourceFlags</i></c> flags."]
    pub flags: ResourceFlags,
}
impl Default for ResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An outward facing structure containing a resource"]
#[repr(C)]
pub struct Resource {
    #[doc = "< pointer to the resource."]
    pub resource: *mut ::std::os::raw::c_void,
    pub name: [widechar; 64usize],
    pub description: ResourceDescription,
    pub state: ResourceStates,
    pub isDepth: bool,
    pub descriptorData: u64,
}
impl Default for Resource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " An internal structure containing a handle to a resource and resource views"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ResourceInternal {
    #[doc = "< The index of the resource."]
    pub internalIndex: i32,
}
#[doc = " A structure defining a resource bind point"]
#[repr(C)]
pub struct ResourceBinding {
    pub slotIndex: u32,
    pub resourceIdentifier: u32,
    pub name: [widechar; 64usize],
}
impl Default for ResourceBinding {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating a single pass of an algorithm."]
#[repr(C)]
pub struct PipelineState {
    #[doc = "< The pipelines rootSignature"]
    pub rootSignature: RootSignature,
    #[doc = "< The pipeline object"]
    pub pipeline: Pipeline,
    #[doc = "< Count of UAVs used in this pipeline"]
    pub uavCount: u32,
    #[doc = "< Count of SRVs used in this pipeline"]
    pub srvCount: u32,
    #[doc = "< Count of constant buffers used in this pipeline"]
    pub constCount: u32,
    #[doc = "< Array of ResourceIdentifiers bound as UAVs"]
    pub uavResourceBindings: [ResourceBinding; 8usize],
    #[doc = "< Array of ResourceIdentifiers bound as SRVs"]
    pub srvResourceBindings: [ResourceBinding; 16usize],
    #[doc = "< Array of ResourceIdentifiers bound as CBs"]
    pub cbResourceBindings: [ResourceBinding; 2usize],
}
impl Default for PipelineState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the data required to create a resource."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateResourceDescription {
    #[doc = "< The heap type to hold the resource, typically <c><i>FFX_HEAP_TYPE_DEFAULT</i></c>."]
    pub heapType: HeapType,
    #[doc = "< A resource description."]
    pub resourceDescription: ResourceDescription,
    #[doc = "< The initial resource state."]
    pub initalState: ResourceStates,
    #[doc = "< Size of initial data buffer."]
    pub initDataSize: u32,
    #[doc = "< Buffer containing data to fill the resource."]
    pub initData: *mut ::std::os::raw::c_void,
    #[doc = "< Name of the resource."]
    pub name: *const widechar,
    #[doc = "< Resource usage flags."]
    pub usage: ResourceUsage,
    #[doc = "< Internal resource ID."]
    pub id: u32,
}
impl Default for CreateResourceDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing the description used to create a\n <c><i>FfxPipeline</i></c> structure.\n\n A pipeline is the name given to a shader and the collection of state that\n is required to dispatch it. In the context of FSR2 and its architecture\n this means that a <c><i>FfxPipelineDescription</i></c> will map to either a\n monolithic object in an explicit API (such as a\n <c><i>PipelineStateObject</i></c> in DirectX 12). Or a shader and some\n ancillary API objects (in something like DirectX 11).\n\n The <c><i>contextFlags</i></c> field contains a copy of the flags passed\n to <c><i>ffxFsr2ContextCreate</i></c> via the <c><i>flags</i></c> field of\n the <c><i>FfxFsr2InitializationParams</i></c> structure. These flags are\n used to determine which permutation of a pipeline for a specific\n <c><i>FfxFsr2Pass</i></c> should be used to implement the features required\n by each application, as well as to acheive the best performance on specific\n target hardware configurations.\n\n When using one of the provided backends for FSR2 (such as DirectX 12 or\n Vulkan) the data required to create a pipeline is compiled offline and\n included into the backend library that you are using. For cases where the\n backend interface is overriden by providing custom callback function\n implementations care should be taken to respect the contents of the\n <c><i>contextFlags</i></c> field in order to correctly support the options\n provided by FSR2, and acheive best performance.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PipelineDescription {
    #[doc = "< A collection of <c><i>FfxFsr2InitializationFlagBits</i></c> which were passed to the context."]
    pub contextFlags: u32,
    #[doc = "< Array of static samplers."]
    pub samplers: *mut FilterType,
    #[doc = "< The number of samples contained inside <c><i>samplers</i></c>."]
    pub samplerCount: usize,
    #[doc = "< Array containing the sizes of the root constant buffers (count of 32 bit elements)."]
    pub rootConstantBufferSizes: *const u32,
    #[doc = "< The number of root constants contained within <c><i>rootConstantBufferSizes</i></c>."]
    pub rootConstantBufferCount: u32,
}
impl Default for PipelineDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure containing a constant buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstantBuffer {
    #[doc = "< Size of 32 bit chunks used in the constant buffer"]
    pub uint32Size: u32,
    #[doc = "< Constant buffer data"]
    pub data: [u32; 64usize],
}
impl Default for ConstantBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a clear render job."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ClearFloatJobDescription {
    #[doc = "< The clear color of the resource."]
    pub color: [f32; 4usize],
    #[doc = "< The resource to be cleared."]
    pub target: ResourceInternal,
}
#[doc = " A structure describing a compute render job."]
#[repr(C)]
pub struct ComputeJobDescription {
    #[doc = "< Compute pipeline for the render job."]
    pub pipeline: PipelineState,
    #[doc = "< Dispatch dimensions."]
    pub dimensions: [u32; 3usize],
    #[doc = "< SRV resources to be bound in the compute job."]
    pub srvs: [ResourceInternal; 16usize],
    pub srvNames: [[widechar; 64usize]; 16usize],
    #[doc = "< UAV resources to be bound in the compute job."]
    pub uavs: [ResourceInternal; 8usize],
    #[doc = "< Mip level of UAV resources to be bound in the compute job."]
    pub uavMip: [u32; 8usize],
    pub uavNames: [[widechar; 64usize]; 8usize],
    #[doc = "< Constant buffers to be bound in the compute job."]
    pub cbs: [ConstantBuffer; 2usize],
    pub cbNames: [[widechar; 64usize]; 2usize],
    #[doc = "< Slot index in the descriptor table"]
    pub cbSlotIndex: [u32; 2usize],
}
impl Default for ComputeJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure describing a copy render job."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CopyJobDescription {
    #[doc = "< Source resource for the copy."]
    pub src: ResourceInternal,
    #[doc = "< Destination resource for the copy."]
    pub dst: ResourceInternal,
}
#[doc = " A structure describing a single render job."]
#[repr(C)]
pub struct GpuJobDescription {
    #[doc = "< Type of the job."]
    pub jobType: GpuJobType,
    pub __bindgen_anon_1: GpuJobDescription__bindgen_ty_1,
}
#[repr(C)]
pub struct GpuJobDescription__bindgen_ty_1 {
    #[doc = "< Clear job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_CLEAR_FLOAT</i></c>."]
    pub clearJobDescriptor: __BindgenUnionField<ClearFloatJobDescription>,
    #[doc = "< Copy job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_COPY</i></c>."]
    pub copyJobDescriptor: __BindgenUnionField<CopyJobDescription>,
    #[doc = "< Compute job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_COMPUTE</i></c>."]
    pub computeJobDescriptor: __BindgenUnionField<ComputeJobDescription>,
    pub bindgen_union_field: [u64; 946usize],
}
impl Default for GpuJobDescription__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GpuJobDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The value of Pi."]
pub const FFX_PI: f32 = 3.1415927410125732;
#[doc = " An epsilon value for floating point numbers."]
pub const FFX_EPSILON: f32 = 0.0000009999999974752427;
#[doc = " A typedef for the callback function for assert printing.\n\n This can be used to re-route printing of assert messages from the FFX backend\n to another destination. For example instead of the default behaviour of printing\n the assert messages to the debugger's TTY the message can be re-routed to a\n MessageBox in a GUI application.\n\n @param [in] message                 The message generated by the assert.\n"]
pub type AssertCallback =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Function to report an assert.\n\n @param [in] file                    The name of the file as a string.\n @param [in] line                    The index of the line in the file.\n @param [in] condition               The boolean condition that was tested.\n @param [in] msg                     The optional message to print.\n\n @returns\n Always returns true.\n"]
    #[link_name = "\u{1}ffxAssertReport"]
    pub fn AssertReport(
        file: *const ::std::os::raw::c_char,
        line: i32,
        condition: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Provides the ability to set a callback for assert messages.\n\n @param [in] callback                The callback function that will receive assert messages.\n"]
    #[link_name = "\u{1}ffxAssertSetPrintingCallback"]
    pub fn AssertSetPrintingCallback(callback: AssertCallback);
}
#[doc = " Typedef for error codes returned from functions in the FidelityFX SDK."]
pub type ErrorCode = i32;
#[doc = "< The operation completed successfully."]
pub const FFX_OK: ErrorCode = 0;
#[doc = "< The operation failed due to an invalid pointer."]
pub const FFX_ERROR_INVALID_POINTER: ErrorCode = -2147483648;
#[doc = "< The operation failed due to an invalid alignment."]
pub const FFX_ERROR_INVALID_ALIGNMENT: ErrorCode = -2147483647;
#[doc = "< The operation failed due to an invalid size."]
pub const FFX_ERROR_INVALID_SIZE: ErrorCode = -2147483646;
#[doc = "< The end of the file was encountered."]
pub const FFX_EOF: ErrorCode = -2147483645;
#[doc = "< The operation failed because the specified path was invalid."]
pub const FFX_ERROR_INVALID_PATH: ErrorCode = -2147483644;
#[doc = "< The operation failed because end of file was reached."]
pub const FFX_ERROR_EOF: ErrorCode = -2147483643;
#[doc = "< The operation failed because of some malformed data."]
pub const FFX_ERROR_MALFORMED_DATA: ErrorCode = -2147483642;
#[doc = "< The operation failed because it ran out memory."]
pub const FFX_ERROR_OUT_OF_MEMORY: ErrorCode = -2147483641;
#[doc = "< The operation failed because the interface was not fully configured."]
pub const FFX_ERROR_INCOMPLETE_INTERFACE: ErrorCode = -2147483640;
#[doc = "< The operation failed because of an invalid enumeration value."]
pub const FFX_ERROR_INVALID_ENUM: ErrorCode = -2147483639;
#[doc = "< The operation failed because an argument was invalid."]
pub const FFX_ERROR_INVALID_ARGUMENT: ErrorCode = -2147483638;
#[doc = "< The operation failed because a value was out of range."]
pub const FFX_ERROR_OUT_OF_RANGE: ErrorCode = -2147483637;
#[doc = "< The operation failed because a device was null."]
pub const FFX_ERROR_NULL_DEVICE: ErrorCode = -2147483636;
#[doc = "< The operation failed because the backend API returned an error code."]
pub const FFX_ERROR_BACKEND_API_ERROR: ErrorCode = -2147483635;
#[doc = "< The operation failed because there was not enough memory."]
pub const FFX_ERROR_INSUFFICIENT_MEMORY: ErrorCode = -2147483634;
#[doc = "< A pass which performs depth clipping."]
pub const FFX_FSR2_PASS_DEPTH_CLIP: Pass = 0;
#[doc = "< A pass which performs reconstruction of previous frame's depth."]
pub const FFX_FSR2_PASS_RECONSTRUCT_PREVIOUS_DEPTH: Pass = 1;
#[doc = "< A pass which calculates pixel locks."]
pub const FFX_FSR2_PASS_LOCK: Pass = 2;
#[doc = "< A pass which performs upscaling."]
pub const FFX_FSR2_PASS_ACCUMULATE: Pass = 3;
#[doc = "< A pass which performs upscaling when sharpening is used."]
pub const FFX_FSR2_PASS_ACCUMULATE_SHARPEN: Pass = 4;
#[doc = "< A pass which performs sharpening."]
pub const FFX_FSR2_PASS_RCAS: Pass = 5;
#[doc = "< A pass which generates the luminance mipmap chain for the current frame."]
pub const FFX_FSR2_PASS_COMPUTE_LUMINANCE_PYRAMID: Pass = 6;
#[doc = "< An optional pass to generate a reactive mask"]
pub const FFX_FSR2_PASS_GENERATE_REACTIVE: Pass = 7;
#[doc = "< An optional pass to generate a texture-and-composition and reactive masks"]
pub const FFX_FSR2_PASS_TCR_AUTOGENERATE: Pass = 8;
#[doc = "< The number of passes performed by FSR2."]
pub const FFX_FSR2_PASS_COUNT: Pass = 9;
#[doc = " An enumeration of all the passes which constitute the FSR2 algorithm.\n\n FSR2 is implemented as a composite of several compute passes each\n computing a key part of the final result. Each call to the\n <c><i>FfxFsr2ScheduleGpuJobFunc</i></c> callback function will\n correspond to a single pass included in <c><i>FfxFsr2Pass</i></c>. For a\n more comprehensive description of each pass, please refer to the FSR2\n reference documentation.\n\n Please note in some cases e.g.: <c><i>FFX_FSR2_PASS_ACCUMULATE</i></c>\n and <c><i>FFX_FSR2_PASS_ACCUMULATE_SHARPEN</i></c> either one pass or the\n other will be used (they are mutually exclusive). The choice of which will\n depend on the way the <c><i>FfxFsr2Context</i></c> is created and the\n precise contents of <c><i>FfxFsr2DispatchParamters</i></c> each time a call\n is made to <c><i>ffxFsr2ContextDispatch</i></c>.\n\n @ingroup FSR2"]
pub type Pass = ::std::os::raw::c_int;
pub const FFX_FSR2_MESSAGE_TYPE_ERROR: MsgType = 0;
pub const FFX_FSR2_MESSAGE_TYPE_WARNING: MsgType = 1;
pub const FFX_FSR2_MESSAGE_TYPE_COUNT: MsgType = 2;
pub type MsgType = ::std::os::raw::c_int;
#[doc = " Create and initialize the backend context.\n\n The callback function sets up the backend context for rendering.\n It will create or reference the device and create required internal data structures.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] device                              The FfxDevice obtained by ffxGetDevice(DX12/VK/...).\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type CreateBackendContextFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, device: Device) -> ErrorCode,
>;
#[doc = " Get a list of capabilities of the device.\n\n When creating an <c><i>FfxFsr2Context</i></c> it is desirable for the FSR2\n core implementation to be aware of certain characteristics of the platform\n that is being targetted. This is because some optimizations which FSR2\n attempts to perform are more effective on certain classes of hardware than\n others, or are not supported by older hardware. In order to avoid cases\n where optimizations actually have the effect of decreasing performance, or\n reduce the breadth of support provided by FSR2, FSR2 queries the\n capabilities of the device to make such decisions.\n\n For target platforms with fixed hardware support you need not implement\n this callback function by querying the device, but instead may hardcore\n what features are available on the platform.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [out] outDeviceCapabilities              The device capabilities structure to fill out.\n @param [in] device                              The device to query for capabilities.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type GetDeviceCapabilitiesFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        outDeviceCapabilities: *mut DeviceCapabilities,
        device: Device,
    ) -> ErrorCode,
>;
#[doc = " Destroy the backend context and dereference the device.\n\n This function is called when the <c><i>FfxFsr2Context</i></c> is destroyed.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type DestroyBackendContextFunc =
    ::std::option::Option<unsafe extern "C" fn(backendInterface: *mut Interface) -> ErrorCode>;
#[doc = " Create a resource.\n\n This callback is intended for the backend to create internal resources.\n\n Please note: It is also possible that the creation of resources might\n itself cause additional resources to be created by simply calling the\n <c><i>FfxFsr2CreateResourceFunc</i></c> function pointer again. This is\n useful when handling the initial creation of resources which must be\n initialized. The flow in such a case would be an initial call to create the\n CPU-side resource, another to create the GPU-side resource, and then a call\n to schedule a copy render job to move the data between the two. Typically\n this type of function call flow is only seen during the creation of an\n <c><i>FfxFsr2Context</i></c>.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] createResourceDescription           A pointer to a <c><i>FfxCreateResourceDescription</i></c>.\n @param [out] outResource                        A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type CreateResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        createResourceDescription: *const CreateResourceDescription,
        outResource: *mut ResourceInternal,
    ) -> ErrorCode,
>;
#[doc = " Register a resource in the backend for the current frame.\n\n Since FSR2 and the backend are not aware how many different\n resources will get passed to FSR2 over time, it's not safe\n to register all resources simultaneously in the backend.\n Also passed resources may not be valid after the dispatch call.\n As a result it's safest to register them as FfxResourceInternal\n and clear them at the end of the dispatch call.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] inResource                          A pointer to a <c><i>FfxResource</i></c>.\n @param [out] outResource                        A pointer to a <c><i>FfxResourceInternal</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type RegisterResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        inResource: *const Resource,
        outResource: *mut ResourceInternal,
    ) -> ErrorCode,
>;
#[doc = " Unregister all temporary FfxResourceInternal from the backend.\n\n Unregister FfxResourceInternal referencing resources passed to\n a function as a parameter.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type UnregisterResourcesFunc =
    ::std::option::Option<unsafe extern "C" fn(backendInterface: *mut Interface) -> ErrorCode>;
#[doc = " Retrieve a <c><i>FfxResourceDescription</i></c> matching a\n <c><i>FfxResource</i></c> structure.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @returns\n A description of the resource.\n\n @ingroup FSR2"]
pub type GetResourceDescriptionFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        resource: ResourceInternal,
    ) -> ResourceDescription,
>;
#[doc = " Destroy a resource\n\n This callback is intended for the backend to release an internal resource.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type DestroyResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, resource: ResourceInternal) -> ErrorCode,
>;
#[doc = " Create a render pipeline.\n\n A rendering pipeline contains the shader as well as resource bindpoints\n and samplers.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] pass                                The identifier for the pass.\n @param [in] pipelineDescription                 A pointer to a <c><i>FfxPipelineDescription</i></c> describing the pipeline to be created.\n @param [out] outPipeline                        A pointer to a <c><i>FfxPipelineState</i></c> structure which should be populated.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type CreatePipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        pass: Pass,
        pipelineDescription: *const PipelineDescription,
        outPipeline: *mut PipelineState,
    ) -> ErrorCode,
>;
#[doc = " Destroy a render pipeline.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [out] pipeline                           A pointer to a <c><i>FfxPipelineState</i></c> structure which should be released.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type DestroyPipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        pipeline: *mut PipelineState,
    ) -> ErrorCode,
>;
#[doc = " Schedule a render job to be executed on the next call of\n <c><i>FfxFsr2ExecuteGpuJobsFunc</i></c>.\n\n Render jobs can perform one of three different tasks: clear, copy or\n compute dispatches.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] job                                 A pointer to a <c><i>FfxGpuJobDescription</i></c> structure.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type ScheduleGpuJobFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut Interface,
        job: *const GpuJobDescription,
    ) -> ErrorCode,
>;
#[doc = " Execute scheduled render jobs on the <c><i>comandList</i></c> provided.\n\n The recording of the graphics API commands should take place in this\n callback function, the render jobs which were previously enqueued (via\n callbacks made to <c><i>FfxFsr2ScheduleGpuJobFunc</i></c>) should be\n processed in the order they were received. Advanced users might choose to\n reorder the rendering jobs, but should do so with care to respect the\n resource dependencies.\n\n Depending on the precise contents of <c><i>FfxFsr2DispatchDescription</i></c> a\n different number of render jobs might have previously been enqueued (for\n example if sharpening is toggled on and off).\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] commandList                         A pointer to a <c><i>FfxCommandList</i></c> structure.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type ExecuteGpuJobsFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut Interface, commandList: CommandList) -> ErrorCode,
>;
#[doc = " Pass a string message\n\n Used for debug messages.\n\n @param [in] type                       The type of message.\n @param [in] message                    A string message to pass.\n\n\n @ingroup FSR2"]
pub type Message =
    ::std::option::Option<unsafe extern "C" fn(type_: MsgType, message: *const widechar)>;
#[doc = " A structure encapsulating the interface between the core implentation of\n the FSR2 algorithm and any graphics API that it should ultimately call.\n\n This set of functions serves as an abstraction layer between FSR2 and the\n API used to implement it. While FSR2 ships with backends for DirectX12 and\n Vulkan, it is possible to implement your own backend for other platforms or\n which sits ontop of your engine's own abstraction layer. For details on the\n expectations of what each function should do you should refer the\n description of the following function pointer types:\n\n     <c><i>FfxFsr2CreateDeviceFunc</i></c>\n     <c><i>FfxFsr2GetDeviceCapabilitiesFunc</i></c>\n     <c><i>FfxFsr2DestroyDeviceFunc</i></c>\n     <c><i>FfxFsr2CreateResourceFunc</i></c>\n     <c><i>FfxFsr2GetResourceDescriptionFunc</i></c>\n     <c><i>FfxFsr2DestroyResourceFunc</i></c>\n     <c><i>FfxFsr2CreatePipelineFunc</i></c>\n     <c><i>FfxFsr2DestroyPipelineFunc</i></c>\n     <c><i>FfxFsr2ScheduleGpuJobFunc</i></c>\n     <c><i>FfxFsr2ExecuteGpuJobsFunc</i></c>\n\n Depending on the graphics API that is abstracted by the backend, it may be\n required that the backend is to some extent stateful. To ensure that\n applications retain full control to manage the memory used by FSR2, the\n <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields are\n provided. A backend should provide a means of specifying how much scratch\n memory is required for its internal implementation (e.g: via a function\n or constant value). The application is that responsible for allocating that\n memory and providing it when setting up the FSR2 backend. Backends provided\n with FSR2 do not perform dynamic memory allocations, and instead\n suballocate all memory from the scratch buffers provided.\n\n The <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields\n should be populated according to the requirements of each backend. For\n example, if using the DirectX 12 backend you should call the\n <c><i>ffxFsr2GetScratchMemorySizeDX12</i></c> function. It is not required\n that custom backend implementations use a scratch buffer.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Interface {
    #[doc = "< A callback function to create and initialize the backend context."]
    pub fpCreateBackendContext: CreateBackendContextFunc,
    #[doc = "< A callback function to query device capabilites."]
    pub fpGetDeviceCapabilities: GetDeviceCapabilitiesFunc,
    #[doc = "< A callback function to destroy the backendcontext. This also dereferences the device."]
    pub fpDestroyBackendContext: DestroyBackendContextFunc,
    #[doc = "< A callback function to create a resource."]
    pub fpCreateResource: CreateResourceFunc,
    #[doc = "< A callback function to register an external resource."]
    pub fpRegisterResource: RegisterResourceFunc,
    #[doc = "< A callback function to unregister external resource."]
    pub fpUnregisterResources: UnregisterResourcesFunc,
    #[doc = "< A callback function to retrieve a resource description."]
    pub fpGetResourceDescription: GetResourceDescriptionFunc,
    #[doc = "< A callback function to destroy a resource."]
    pub fpDestroyResource: DestroyResourceFunc,
    #[doc = "< A callback function to create a render or compute pipeline."]
    pub fpCreatePipeline: CreatePipelineFunc,
    #[doc = "< A callback function to destroy a render or compute pipeline."]
    pub fpDestroyPipeline: DestroyPipelineFunc,
    #[doc = "< A callback function to schedule a render job."]
    pub fpScheduleGpuJob: ScheduleGpuJobFunc,
    #[doc = "< A callback function to execute all queued render jobs."]
    pub fpExecuteGpuJobs: ExecuteGpuJobsFunc,
    #[doc = "< A preallocated buffer for memory utilized internally by the backend."]
    pub scratchBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< Size of the buffer pointed to by <c><i>scratchBuffer</i></c>."]
    pub scratchBufferSize: usize,
}
impl Default for Interface {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.5x."]
pub const FFX_FSR2_QUALITY_MODE_QUALITY: QualityMode = 1;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.7x."]
pub const FFX_FSR2_QUALITY_MODE_BALANCED: QualityMode = 2;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 2.0x."]
pub const FFX_FSR2_QUALITY_MODE_PERFORMANCE: QualityMode = 3;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 3.0x."]
pub const FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE: QualityMode = 4;
#[doc = " An enumeration of all the quality modes supported by FidelityFX Super\n Resolution 2 upscaling.\n\n In order to provide a consistent user experience across multiple\n applications which implement FSR2. It is strongly recommended that the\n following preset scaling factors are made available through your\n application's user interface.\n\n If your application does not expose the notion of preset scaling factors\n for upscaling algorithms (perhaps instead implementing a fixed ratio which\n is immutable) or implementing a more dynamic scaling scheme (such as\n dynamic resolution scaling), then there is no need to use these presets.\n\n Please note that <c><i>FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> is\n an optional mode which may introduce significant quality degradation in the\n final image. As such it is recommended that you evaluate the final results\n of using this scaling mode before deciding if you should include it in your\n application.\n\n @ingroup FSR2"]
pub type QualityMode = ::std::os::raw::c_int;
#[doc = "< A bit indicating if the input color data provided is using a high-dynamic range."]
pub const FFX_FSR2_ENABLE_HIGH_DYNAMIC_RANGE: InitializationFlagBits = 1;
#[doc = "< A bit indicating if the motion vectors are rendered at display resolution."]
pub const FFX_FSR2_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS: InitializationFlagBits = 2;
#[doc = "< A bit indicating that the motion vectors have the jittering pattern applied to them."]
pub const FFX_FSR2_ENABLE_MOTION_VECTORS_JITTER_CANCELLATION: InitializationFlagBits = 4;
#[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
pub const FFX_FSR2_ENABLE_DEPTH_INVERTED: InitializationFlagBits = 8;
#[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
pub const FFX_FSR2_ENABLE_DEPTH_INFINITE: InitializationFlagBits = 16;
#[doc = "< A bit indicating if automatic exposure should be applied to input color data."]
pub const FFX_FSR2_ENABLE_AUTO_EXPOSURE: InitializationFlagBits = 32;
#[doc = "< A bit indicating that the application uses dynamic resolution scaling."]
pub const FFX_FSR2_ENABLE_DYNAMIC_RESOLUTION: InitializationFlagBits = 64;
#[doc = "< A bit indicating that the backend should use 1D textures."]
pub const FFX_FSR2_ENABLE_TEXTURE1D_USAGE: InitializationFlagBits = 128;
#[doc = "< A bit indicating that the runtime should check some API values and report issues."]
pub const FFX_FSR2_ENABLE_DEBUG_CHECKING: InitializationFlagBits = 256;
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFsr2Context</i></c>. See <c><i>FfxFsr2ContextDescription</i></c>.\n\n @ingroup FSR2"]
pub type InitializationFlagBits = ::std::os::raw::c_int;
#[doc = " A structure encapsulating the parameters required to initialize FidelityFX\n Super Resolution 2 upscaling.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ContextDescription {
    #[doc = "< A collection of <c><i>FfxFsr2InitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: Dimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the upscaling process."]
    pub displaySize: Dimensions2D,
    #[doc = "< A set of pointers to the backend implementation for FSR 2.0."]
    pub callbacks: Interface,
    #[doc = "< The abstracted device which is passed to some callback functions."]
    pub device: Device,
    #[doc = "< A pointer to a function that can recieve messages from the runtime."]
    pub fpMessage: Message,
}
impl Default for ContextDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Super Resolution 2.\n\n @ingroup FSR2"]
#[repr(C)]
pub struct DispatchDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR2 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the color buffer for the current frame (at render resolution)."]
    pub color: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth values for the current frame (at render resolution)."]
    pub depth: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 2-dimensional motion vectors (at render resolution if <c><i>FFX_FSR2_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing a 1x1 exposure value."]
    pub exposure: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of reactive objects in the scene."]
    pub reactive: Resource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of special objects in the scene."]
    pub transparencyAndComposition: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output color buffer for the current frame (at presentation resolution)."]
    pub output: Resource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: FloatCoords2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< Enable an additional sharpening pass."]
    pub enableSharpening: bool,
    #[doc = "< The sharpness value between 0 and 1, where 0 is no additional sharpness and 1 is maximum additional sharpness."]
    pub sharpness: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< The pre exposure value (must be > 0.0f)"]
    pub preExposure: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera. This is used only used in case of non infinite depth."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
    #[doc = "< The scale factor to convert view space units to meters"]
    pub viewSpaceToMetersFactor: f32,
    #[doc = "< A boolean value to indicate internal reactive autogeneration should be used"]
    pub enableAutoReactive: bool,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque only color buffer for the current frame (at render resolution)."]
    pub colorOpaqueOnly: Resource,
    #[doc = "< Cutoff value for TC"]
    pub autoTcThreshold: f32,
    #[doc = "< A value to scale the transparency and composition mask"]
    pub autoTcScale: f32,
    #[doc = "< A value to scale the reactive mask"]
    pub autoReactiveScale: f32,
    #[doc = "< A value to clamp the reactive mask"]
    pub autoReactiveMax: f32,
}
impl Default for DispatchDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the parameters for automatic generation of a reactive mask\n\n @ingroup FSR2"]
#[repr(C)]
pub struct GenerateReactiveDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR2 rendering commands into."]
    pub commandList: CommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque only color buffer for the current frame (at render resolution)."]
    pub colorOpaqueOnly: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque+translucent color buffer for the current frame (at render resolution)."]
    pub colorPreUpscale: Resource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the surface to generate the reactive mask into."]
    pub outReactive: Resource,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: Dimensions2D,
    #[doc = "< A value to scale the output"]
    pub scale: f32,
    #[doc = "< A threshold value to generate a binary reactive mask"]
    pub cutoffThreshold: f32,
    #[doc = "< A value to set for the binary reactive mask"]
    pub binaryValue: f32,
    #[doc = "< Flags to determine how to generate the reactive mask"]
    pub flags: u32,
}
impl Default for GenerateReactiveDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 2 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR2.\n\n The <c><i>FfxFsr2Context</i></c> object should have a lifetime matching\n your use of FSR2. Before destroying the FSR2 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR2.\n It is therefore recommended that the GPU is idle before destroying the\n FSR2 context.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Context {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 16536usize],
}
impl Default for Context {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 2 context from the parameters\n programmed to the <c><i>FfxFsr2CreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR2\n API, and is responsible for the management of the internal resources used\n by the FSR2 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR2's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr2Context</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr2Context</i></c> how match the configuration of your\n application as well as the intended use of FSR2. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr2DispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR2 should be integerated into an application.\n\n When the <c><i>FfxFsr2Context</i></c> is created, you should use the\n <c><i>ffxFsr2ContextDispatch</i></c> function each frame where FSR2\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr2ContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr2Context</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR2 upscaling is\n disabled by a user. To destroy the FSR2 context you should call\n <c><i>ffxFsr2ContextDestroy</i></c>.\n\n @param [out] context                A pointer to a <c><i>FfxFsr2Context</i></c> structure to populate.\n @param [in]  contextDescription     A pointer to a <c><i>FfxFsr2ContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr2ContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FSR2"]
    #[link_name = "\u{1}ffxFsr2ContextCreate"]
    pub fn ContextCreate(
        context: *mut Context,
        contextDescription: *const ContextDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Dispatch the various passes that constitute FidelityFX Super Resolution 2.\n\n FSR2 is a composite effect, meaning that it is compromised of multiple\n constituent passes (implemented as one or more clears, copies and compute\n dispatches). The <c><i>ffxFsr2ContextDispatch</i></c> function is the\n function which (via the use of the functions contained in the\n <c><i>callbacks</i></c> field of the <c><i>FfxFsr2Context</i></c>\n structure) utlimately generates the sequence of graphics API calls required\n each frame.\n\n As with the creation of the <c><i>FfxFsr2Context</i></c> correctly\n programming the <c><i>FfxFsr2DispatchDescription</i></c> is key to ensuring\n the correct operation of FSR2. It is particularly important to ensure that\n camera jitter is correctly applied to your application's projection matrix\n (or camera origin for raytraced applications). FSR2 provides the\n <c><i>ffxFsr2GetJitterPhaseCount</i></c> and\n <c><i>ffxFsr2GetJitterOffset</i></c> entry points to help applications\n correctly compute the camera jitter. Whatever jitter pattern is used by the\n application it should be correctly programmed to the\n <c><i>jitterOffset</i></c> field of the <c><i>dispatchDescription</i></c>\n structure. For more guidance on camera jitter please consult the\n documentation for <c><i>ffxFsr2GetJitterOffset</i></c> as well as the\n accompanying overview documentation for FSR2.\n\n @param [in] context                 A pointer to a <c><i>FfxFsr2Context</i></c> structure.\n @param [in] dispatchDescription     A pointer to a <c><i>FfxFsr2DispatchDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>dispatchDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_OUT_OF_RANGE              The operation failed because <c><i>dispatchDescription.renderSize</i></c> was larger than the maximum render resolution.\n @retval\n FFX_ERROR_NULL_DEVICE               The operation failed because the device inside the context was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FSR2"]
    #[link_name = "\u{1}ffxFsr2ContextDispatch"]
    pub fn ContextDispatch(
        context: *mut Context,
        dispatchDescription: *const DispatchDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function generate a Reactive mask from an opaque only texure and one containing translucent objects.\n\n @param [in] context                 A pointer to a <c><i>FfxFsr2Context</i></c> structure.\n @param [in] params                  A pointer to a <c><i>FfxFsr2GenerateReactiveDescription</i></c> structure\n\n @retval\n FFX_OK                              The operation completed successfully.\n\n @ingroup FSR2"]
    #[link_name = "\u{1}ffxFsr2ContextGenerateReactiveMask"]
    pub fn ContextGenerateReactiveMask(
        context: *mut Context,
        params: *const GenerateReactiveDescription,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] context                A pointer to a <c><i>FfxFsr2Context</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup FSR2"]
    #[link_name = "\u{1}ffxFsr2ContextDestroy"]
    pub fn ContextDestroy(context: *mut Context) -> ErrorCode;
}
extern "C" {
    #[doc = " Get the upscale ratio from the quality mode.\n\n The following table enumerates the mapping of the quality modes to\n per-dimension scaling ratios.\n\n Quality preset                                        | Scale factor\n ----------------------------------------------------- | -------------\n <c><i>FFX_FSR2_QUALITY_MODE_QUALITY</i></c>           | 1.5x\n <c><i>FFX_FSR2_QUALITY_MODE_BALANCED</i></c>          | 1.7x\n <c><i>FFX_FSR2_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x\n <c><i>FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x\n\n Passing an invalid <c><i>qualityMode</i></c> will return 0.0f.\n\n @param [in] qualityMode             The quality mode preset.\n\n @returns\n The upscaling the per-dimension upscaling ratio for\n <c><i>qualityMode</i></c> according to the table above.\n\n @ingroup FSR2"]
    #[link_name = "\u{1}ffxFsr2GetUpscaleRatioFromQualityMode"]
    pub fn GetUpscaleRatioFromQualityMode(qualityMode: QualityMode) -> f32;
}
extern "C" {
    #[doc = " A helper function to calculate the rendering resolution from a target\n resolution and desired quality level.\n\n This function applies the scaling factor returned by\n <c><i>ffxFsr2GetUpscaleRatioFromQualityMode</i></c> to each dimension.\n\n @param [out] renderWidth            A pointer to a <c>uint32_t</c> which will hold the calculated render resolution width.\n @param [out] renderHeight           A pointer to a <c>uint32_t</c> which will hold the calculated render resolution height.\n @param [in] displayWidth            The target display resolution width.\n @param [in] displayHeight           The target display resolution height.\n @param [in] qualityMode             The desired quality mode for FSR 2 upscaling.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>renderWidth</i></c> or <c><i>renderHeight</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ENUM              An invalid quality mode was specified.\n\n @ingroup FSR2"]
    #[link_name = "\u{1}ffxFsr2GetRenderResolutionFromQualityMode"]
    pub fn GetRenderResolutionFromQualityMode(
        renderWidth: *mut u32,
        renderHeight: *mut u32,
        displayWidth: u32,
        displayHeight: u32,
        qualityMode: QualityMode,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function to calculate the jitter phase count from display\n resolution.\n\n For more detailed information about the application of camera jitter to\n your application's rendering please refer to the\n <c><i>ffxFsr2GetJitterOffset</i></c> function.\n\n The table below shows the jitter phase count which this function\n would return for each of the quality presets.\n\n Quality preset                                        | Scale factor  | Phase count\n ----------------------------------------------------- | ------------- | ---------------\n <c><i>FFX_FSR2_QUALITY_MODE_QUALITY</i></c>           | 1.5x          | 18\n <c><i>FFX_FSR2_QUALITY_MODE_BALANCED</i></c>          | 1.7x          | 23\n <c><i>FFX_FSR2_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x          | 32\n <c><i>FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x          | 72\n Custom                                                | [1..n]x       | ceil(8*n^2)\n\n @param [in] renderWidth             The render resolution width.\n @param [in] displayWidth            The display resolution width.\n\n @returns\n The jitter phase count for the scaling factor between <c><i>renderWidth</i></c> and <c><i>displayWidth</i></c>.\n\n @ingroup FSR2"]
    #[link_name = "\u{1}ffxFsr2GetJitterPhaseCount"]
    pub fn GetJitterPhaseCount(renderWidth: i32, displayWidth: i32) -> i32;
}
extern "C" {
    #[doc = " A helper function to calculate the subpixel jitter offset.\n\n FSR2 relies on the application to apply sub-pixel jittering while rendering.\n This is typically included in the projection matrix of the camera. To make\n the application of camera jitter simple, the FSR2 API provides a small set\n of utility function which computes the sub-pixel jitter offset for a\n particular frame within a sequence of separate jitter offsets. To begin, the\n index within the jitter phase must be computed. To calculate the\n sequence's length, you can call the <c><i>ffxFsr2GetJitterPhaseCount</i></c>\n function. The index should be a value which is incremented each frame modulo\n the length of the sequence computed by <c><i>ffxFsr2GetJitterPhaseCount</i></c>.\n The index within the jitter phase  is passed to\n <c><i>ffxFsr2GetJitterOffset</i></c> via the <c><i>index</i></c> parameter.\n\n This function uses a Halton(2,3) sequence to compute the jitter offset.\n The ultimate index used for the sequence is <c><i>index</i></c> %\n <c><i>phaseCount</i></c>.\n\n It is important to understand that the values returned from the\n <c><i>ffxFsr2GetJitterOffset</i></c> function are in unit pixel space, and\n in order to composite this correctly into a projection matrix we must\n convert them into projection offsets. This is done as per the pseudo code\n listing which is shown below.\n\n     const int32_t jitterPhaseCount = ffxFsr2GetJitterPhaseCount(renderWidth, displayWidth);\n\n     float jitterX = 0;\n     float jitterY = 0;\n     ffxFsr2GetJitterOffset(&jitterX, &jitterY, index, jitterPhaseCount);\n\n     const float jitterX = 2.0f * jitterX / (float)renderWidth;\n     const float jitterY = -2.0f * jitterY / (float)renderHeight;\n     const Matrix4 jitterTranslationMatrix = translateMatrix(Matrix3::identity, Vector3(jitterX, jitterY, 0));\n     const Matrix4 jitteredProjectionMatrix = jitterTranslationMatrix * projectionMatrix;\n\n Jitter should be applied to all rendering. This includes opaque, alpha\n transparent, and raytraced objects. For rasterized objects, the sub-pixel\n jittering values calculated by the <c><i>iffxFsr2GetJitterOffset</i></c>\n function can be applied to the camera projection matrix which is ultimately\n used to perform transformations during vertex shading. For raytraced\n rendering, the sub-pixel jitter should be applied to the ray's origin,\n often the camera's position.\n\n Whether you elect to use the <c><i>ffxFsr2GetJitterOffset</i></c> function\n or your own sequence generator, you must program the\n <c><i>jitterOffset</i></c> field of the\n <c><i>FfxFsr2DispatchParameters</i></c> structure in order to inform FSR2\n of the jitter offset that has been applied in order to render each frame.\n\n If not using the recommended <c><i>ffxFsr2GetJitterOffset</i></c> function,\n care should be taken that your jitter sequence never generates a null vector;\n that is value of 0 in both the X and Y dimensions.\n\n @param [out] outX                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the x dimension.\n @param [out] outY                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the y dimension.\n @param [in] index                   The index within the jitter sequence.\n @param [in] phaseCount              The length of jitter phase. See <c><i>ffxFsr2GetJitterPhaseCount</i></c>.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>outX</i></c> or <c><i>outY</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Argument <c><i>phaseCount</i></c> must be greater than 0.\n\n @ingroup FSR2"]
    #[link_name = "\u{1}ffxFsr2GetJitterOffset"]
    pub fn GetJitterOffset(
        outX: *mut f32,
        outY: *mut f32,
        index: i32,
        phaseCount: i32,
    ) -> ErrorCode;
}
extern "C" {
    #[doc = " A helper function to check if a resource is\n <c><i>FFX_FSR2_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @param [in] resource                A <c><i>FfxResource</i></c>.\n\n @returns\n true                                The <c><i>resource</i></c> was not <c><i>FFX_FSR2_RESOURCE_IDENTIFIER_NULL</i></c>.\n @returns\n false                               The <c><i>resource</i></c> was <c><i>FFX_FSR2_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @ingroup FSR2"]
    #[link_name = "\u{1}ffxFsr2ResourceIsNull"]
    pub fn ResourceIsNull(resource: Resource) -> bool;
}
